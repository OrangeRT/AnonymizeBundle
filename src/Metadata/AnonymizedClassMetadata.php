<?php
/******************************************************************************
 * Copyright (c) 2017.                                                        *
 ******************************************************************************/

namespace OrangeRT\AnonymizeBundle\Metadata;


use Metadata\MergeableClassMetadata;
use Metadata\MergeableInterface;
use Psr\Log\InvalidArgumentException;

/**
 * Class AnonymizedClassMetadata
 * @package OrangeRT\AnonymizeBundle\Metadata
 */
class AnonymizedClassMetadata extends MergeableClassMetadata
{
    const INCLUDE = 0;
    const EXCLUDE = 1;

    private $matchers = [];

    private $method = self::INCLUDE;

    /**
     * @var bool Property to define whether this annotation could be excluded.
     */
    private $couldExclude = false;

    /**
     * @return int
     */
    public function getMethod(): int
    {
        return $this->method;
    }

    /**
     * @param int $method
     */
    public function setMethod(int $method)
    {
        if (!in_array($method, [self::INCLUDE, self::EXCLUDE])) {
            throw new InvalidArgumentException(sprintf("The method %d is not a valid method", $method));
        }
        $this->method = $method;
    }

    /**
     * @param $object \stdClass|string The entity to check whether it should be included in the anonymization process.
     * @return bool
     */
    public function shouldInclude($object)
    {
        $reflection = new \ReflectionClass($object);
        foreach ($this->getMatchers() as $property => $matches) {
            if ($reflection->hasProperty($property)) {
                $prop = $reflection->getProperty($property);
                $prop->setAccessible(true);

                $value = $prop->getValue($object);

                if (is_string($matches) && (false !== stripos($value, $matches) || preg_match($matches, $value))) {
                    return $this->method === self::INCLUDE;
                }
            }
        }
        return $this->method === self::EXCLUDE;
    }

    /**
     * @return array
     */
    public function getMatchers(): array
    {
        return $this->matchers;
    }

    /**
     * @param array $matchers
     */
    public function setMatchers(array $matchers)
    {
        $this->matchers = $matchers;
    }

    /**
     * @return bool
     */
    public function isCouldExclude(): bool
    {
        return $this->couldExclude;
    }

    /**
     * @param bool $couldExclude
     */
    public function setCouldExclude(bool $couldExclude)
    {
        $this->couldExclude = $couldExclude;
    }

    public function merge(MergeableInterface $object)
    {
        parent::merge($object); // TODO: Change the autogenerated stub

        if ($object instanceof self) {
            $this->couldExclude = $object->couldExclude || $this->couldExclude;
            $this->matchers = $object->matchers ?? $this->matchers;
            $this->method = $object->method ?? $this->method;
        }
    }
}